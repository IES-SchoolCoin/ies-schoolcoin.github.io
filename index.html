<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SCHOOLCOIN - Corregido actualizaciones</title>

  <style>
    :root{--bg:#f7d54a;--top:#000;--btn:#8b5e3c;--text:#222;}
    html,body{height:100%;margin:0;font-family:Inter,Arial,sans-serif;background:var(--bg);color:var(--text);}
    .contenedor{width:100%;max-width:420px;margin:0 auto;padding:16px;box-sizing:border-box;}
    .top-bar{background:var(--top);color:#fff;padding:10px;font-weight:700;text-align:center;border-radius:8px;}
    .header{margin-top:14px;font-size:22px;font-weight:800;text-align:center;}
    .coin-logo{width:96px;height:96px;margin:14px auto;}
    .coin-logo img{width:100%;height:100%;object-fit:contain;display:block;}
    .valor-actual{font-size:30px;font-weight:800;margin-top:8px;}
    .meta-line{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-top:6px;font-size:13px;color:#333;}
    .chart-wrap{width:100%;margin-top:14px;background:transparent;border-radius:12px;padding:6px;}
    canvas{width:100% !important;height:320px !important;display:block;}
    .botones{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:16px;}
    .boton{background:var(--btn);color:#fff;padding:12px;border-radius:10px;font-weight:700;text-align:center;cursor:pointer;user-select:none;}
    .info-box{margin-top:12px;background:rgba(0,0,0,0.06);padding:10px;border-radius:8px;font-size:13px;}
    .controls{display:flex;gap:8px;margin-top:10px;justify-content:center;}
    .control-btn{background:#fff;border:1px solid #ccc;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;}
    @media (max-width:400px){ .botones{grid-template-columns:1fr;} canvas{height:260px !important;} }
  </style>
</head>
<body>
  <div class="contenedor">
    <div class="top-bar">SCHOOLCOIN</div>
    <div class="header">IES-SchoolCoin</div>

    <div class="coin-logo"><img src="LOGO.png" alt="Logo SCHOOLCOIN"></div>

    <div class="valor-actual" id="valorActual">0.00 €</div>
    <div class="meta-line">
      <div id="trendText">—</div>
      <div id="timestamp">—</div>
    </div>

    <div class="chart-wrap"><canvas id="grafica"></canvas></div>

    <div class="botones">
      <div class="boton" id="btnEnviar">Enviar</div>
      <div class="boton" id="btnIngresos">Ingresos</div>
      <div class="boton" id="btnGastos">Gastos</div>
      <div class="boton" id="btnCuenta">Mi cuenta</div>
    </div>

    <div class="controls">
      <button class="control-btn" id="pauseBtn">Pausar actualizaciones</button>
      <button class="control-btn" id="addSample">Añadir valor ahora</button>
    </div>

    <div class="info-box" id="infoBox">Toca o haz clic en un punto para ver su fecha, hora y valor.</div>
  </div>

  <!-- Chart.js + adaptador de fechas -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/date-fns@2.30.0/dist/date-fns.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

  <script>
    // CONFIG
    const UPDATE_INTERVAL_MS = 5000;
    const PRESET_POINTS = 600; // reduce si el rendimiento baja
    const BASE = 0.175;
    const MIN = 0.15;
    const MAX = 0.20;

    // UTIL
    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function formatMoney(v){return Number(v).toFixed(2)+' €';}
    function formatDate(d){return d.toLocaleString('es-ES',{year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit'});}

    function nextValue(prev){
      const meanReversion = (BASE - prev) * 0.08;
      const noise = (Math.random() - 0.5) * 0.006;
      return Number(clamp(prev + meanReversion + noise, MIN, MAX).toFixed(4));
    }

    // GENERAR SERIE INICIAL (timestamps deterministas)
    function generateInitialSeries(){
      const labels = [];
      const data = [];
      const nowAligned = Math.floor(Date.now() / UPDATE_INTERVAL_MS) * UPDATE_INTERVAL_MS;
      const start = nowAligned - (PRESET_POINTS - 1) * UPDATE_INTERVAL_MS;
      let val = BASE + (Math.random() - 0.5) * 0.01;
      for(let i=0;i<PRESET_POINTS;i++){
        labels.push(new Date(start + i * UPDATE_INTERVAL_MS));
        val = nextValue(val);
        data.push(val);
      }
      return {labels,data};
    }

    const initial = generateInitialSeries();
    const labels = initial.labels.slice();
    const values = initial.data.slice();

    // UI refs
    const valorActualEl = document.getElementById('valorActual');
    const timestampEl = document.getElementById('timestamp');
    const trendTextEl = document.getElementById('trendText');
    const infoBox = document.getElementById('infoBox');

    function updateMainDisplay(value,date){
      valorActualEl.textContent = formatMoney(value);
      timestampEl.textContent = formatDate(date);
      const prev = values.length>1 ? values[values.length-2] : value;
      const diff = value - prev;
      const arrow = diff>0 ? '▲' : (diff<0 ? '▼' : '—');
      const pct = prev ? ((diff/prev)*100).toFixed(2)+'%' : '';
      trendTextEl.textContent = arrow + ' ' + pct;
    }

    // CHART: pointRadius scriptable para mostrar solo punto activo
    const ctx = document.getElementById('grafica').getContext('2d');
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          label: 'SCHOOLCOIN',
          data: values,
          borderColor: '#0b8a3e',
          backgroundColor: 'rgba(11,138,62,0.12)',
          pointRadius: (ctx) => ctx.active ? 6 : 0,
          pointHoverRadius: 6,
          pointHitRadius: 12,
          tension: 0.25,
          fill: true
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 0 }, // sin animaciones para evitar estados intermedios
        interaction: { mode: 'nearest', intersect: false },
        plugins: {
          legend: { display: false },
          tooltip: {
            enabled: true,
            external: null,
            callbacks: {
              label: function(c){
                const v = Number(c.parsed.y).toFixed(4);
                const date = c.label instanceof Date ? formatDate(c.label) : c.label;
                return ` ${v} € — ${date}`;
              }
            }
          }
        },
        scales: {
          x: {
            type: 'time',
            time: { unit: 'second', displayFormats: { second: 'HH:mm:ss' } },
            grid: { display: false },
            ticks: { color: '#333', maxRotation: 0, autoSkip: true, maxTicksLimit: 8 }
          },
          y: {
            beginAtZero: false,
            suggestedMin: MIN - 0.01,
            suggestedMax: MAX + 0.01,
            grid: { display: false },
            ticks: { callback: v => Number(v).toFixed(2)+' €', color: '#333' }
          }
        }
      }
    });

    // Limpia selección activa y tooltip de forma segura
    function clearActiveSelection(){
      try{
        chart.setActiveElements([]);
        chart.tooltip.setActiveElements([], {x:0,y:0});
        chart.update('none');
      }catch(e){}
    }

    // Resaltar punto seleccionado
    function highlightPoint(index){
      if(index == null) return;
      clearActiveSelection();
      const active = [{datasetIndex:0, index}];
      chart.setActiveElements(active);
      const x = chart.scales.x.getPixelForValue(chart.data.labels[index]);
      const y = chart.scales.y.getPixelForValue(chart.data.datasets[0].data[index]);
      chart.tooltip.setActiveElements(active, {x,y});
      chart.update('none');
      const val = chart.data.datasets[0].data[index];
      const lab = chart.data.labels[index];
      infoBox.textContent = `Punto: ${Number(val).toFixed(4)} € — ${formatDate(new Date(lab))}`;
    }

    // Evitar puntos "pegados" al salir del canvas
    const canvasEl = document.getElementById('grafica');
    canvasEl.addEventListener('mouseleave', () => clearActiveSelection());

    // Click y touch handlers
    canvasEl.addEventListener('click', (evt) => {
      const pts = chart.getElementsAtEventForMode(evt, 'nearest', {intersect: true}, true);
      if(pts.length) highlightPoint(pts[0].index);
      else {
        const pts2 = chart.getElementsAtEventForMode(evt, 'nearest', {intersect: false}, true);
        if(pts2.length) highlightPoint(pts2[0].index);
      }
    });

    canvasEl.addEventListener('touchend', (e) => {
      if(e.changedTouches && e.changedTouches.length){
        const t = e.changedTouches[0];
        const simulated = {clientX: t.clientX, clientY: t.clientY};
        const pts = chart.getElementsAtEventForMode(simulated, 'nearest', {intersect: true}, true);
        if(pts.length) highlightPoint(pts[0].index);
        else {
          const pts2 = chart.getElementsAtEventForMode(simulated, 'nearest', {intersect: false}, true);
          if(pts2.length) highlightPoint(pts2[0].index);
        }
      }
    }, {passive:true});

    // Mostrar valor inicial
    updateMainDisplay(values[values.length-1], new Date(labels[labels.length-1]));

    // ACTUALIZACIONES deterministas y seguras
    let paused = false;
    let updateTimer = null;

    function pushNewPoint(nextDate, newVal){
      // limpiar selección antes de tocar datos
      clearActiveSelection();
      // insertar
      chart.data.labels.push(nextDate);
      chart.data.datasets[0].data.push(newVal);
      if(chart.data.labels.length > PRESET_POINTS){
        chart.data.labels.shift();
        chart.data.datasets[0].data.shift();
      }
      // actualizar sin animación
      chart.update('none');
      // pequeña espera y limpieza final para evitar estados intermedios
      setTimeout(() => {
        clearActiveSelection();
      }, 20);
      // mantener arrays locales
      labels.push(nextDate);
      values.push(newVal);
      if(labels.length > PRESET_POINTS){ labels.shift(); values.shift(); }
      updateMainDisplay(newVal, nextDate);
    }

    function scheduleNextUpdate(){
      if(updateTimer) clearInterval(updateTimer);
      updateTimer = setInterval(() => {
        if(paused) return;
        const lastLabel = chart.data.labels[chart.data.labels.length-1];
        const lastTime = (lastLabel instanceof Date) ? lastLabel.getTime() : new Date(lastLabel).getTime();
        const nextTime = new Date(lastTime + UPDATE_INTERVAL_MS);
        const prev = Number(chart.data.datasets[0].data[chart.data.datasets[0].data.length-1]);
        const nv = nextValue(prev);
        pushNewPoint(nextTime, nv);
      }, UPDATE_INTERVAL_MS);
    }

    scheduleNextUpdate();

    // Controles
    document.getElementById('pauseBtn').addEventListener('click', () => {
      paused = !paused;
      document.getElementById('pauseBtn').textContent = paused ? 'Reanudar actualizaciones' : 'Pausar actualizaciones';
    });

    document.getElementById('addSample').addEventListener('click', () => {
      const lastLabel = chart.data.labels[chart.data.labels.length-1];
      const lastTime = (lastLabel instanceof Date) ? lastLabel.getTime() : new Date(lastLabel).getTime();
      const nextTime = new Date(lastTime + UPDATE_INTERVAL_MS);
      const prev = Number(chart.data.datasets[0].data[chart.data.datasets[0].data.length-1]);
      const nv = nextValue(prev);
      pushNewPoint(nextTime, nv);
    });

    // Forzar render inicial
    window.addEventListener('load', () => setTimeout(()=>chart.resize(),100));
  </script>
</body>
</html>